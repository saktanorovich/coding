using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace coding.leetcode {
    public class Solution_0928 {
        public int MinMalwareSpread(int[][] graph, int[] initial) {
            if (graph.Length < 0) {
                return new Small(graph).doit(initial);
            } else {
                return new Large(graph).doit(initial);
            }
        }

        private class Small {
            private readonly int[][] graph;

            public Small(int[][] graph) {
                this.graph = graph;
            }

            public int doit(int[] initial) {
                var score = -1;
                var index = -1;
                foreach (var node in initial.OrderBy(x => x)) {
                    var have = count(initial, node);
                    if (index == - 1 || score > have) {
                        index = node;
                        score = have;
                    }
                }
                return index;
            }

            private int count(int[] initial, int skip) {
                var queue = new Queue<int>();
                var marks = new int[graph.Length];
                foreach (var node in initial) {
                    if (node != skip) {
                        queue.Enqueue(node);
                        marks[node] = 1;
                    }
                }
                while (queue.Count > 0) {
                    var node = queue.Dequeue();
                    for (var next = 0; next < graph.Length; ++next) {
                        if (next != skip && graph[node][next] > 0) {
                            if (marks[next] == 0) {
                                marks[next] = 1;
                                queue.Enqueue(next);
                            }
                        }
                    }
                }
                return marks.Sum();
            }
        }

        private class Large {
            private readonly int[][] graph;

            public Large(int[][] graph) {
                this.graph = graph;
            }

            public int doit(int[] initial) {
                var reach = new List<int>[graph.Length];
                for (var node = 0; node < graph.Length; ++node) {
                    reach[node] = new List<int>();
                }
                var clean = new int[graph.Length];
                foreach (var from in initial) {
                    clean[from] = -1;
                }
                foreach (var from in initial) {
                    var visited = dfs(graph, clean, from, new HashSet<int>());
                    foreach (var node in visited) {
                        reach[node].Add(from);
                    }
                }
                var count = new int[graph.Length];
                for (var node = 0; node < graph.Length; ++node) {
                    if (clean[node] == 0) {
                        if (reach[node].Count == 1) {
                            count[reach[node].Single()]++;
                        }
                    }
                }
                var score = -1;
                var index = -1;
                foreach (var node in initial.OrderBy(x => x)) {
                    if (index == - 1 || score < count[node]) {
                        index = node;
                        score = count[node];
                    }
                }
                return index;
            }

            private HashSet<int> dfs(int[][] graph, int[] clean, int node, HashSet<int> visited) {
                for (var next = 0; next < graph.Length; ++next) {
                    if (graph[node][next] > 0 && clean[next] == 0) {
                        if (visited.Add(next)) {
                            dfs(graph, clean, next, visited);
                        }
                    }
                }
                return visited;
            }
        }
    }
}
